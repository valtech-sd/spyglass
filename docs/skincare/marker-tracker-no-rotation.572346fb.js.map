{"version":3,"sources":["components/marker-tracker-no-rotation.js"],"names":["AFRAME","registerComponent","schema","marker","type","default","visibilityOnly","visibilityTrigger","isPromiscuous","lossThreshold","init","el","object3D","isShown","data","lossTime","constantZ","trackedMarkers","allMarkers","document","querySelectorAll","markerElement","getElementById","push","positionOffset","position","clone","update","tick","isVisible","positionToApply","isMainMarker","trackedIndex","forEach","index","visible","size","getAttribute","scalarAmount","multiplyScalar","origin","updatedPosition","positionChange","THREE","Vector3","markerPos","x","z","y","smoothAmount","weightedCurrentPos","weightedUpdatedPos","smoothedResult","add","copy","exceededMarkerLossThreshold","Date","now","currentTime","delta","Math","abs","remove","pause","play"],"mappings":"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","file":"marker-tracker-no-rotation.572346fb.js","sourceRoot":"../../src","sourcesContent":["// This component flips the coordinate frame of an object as a convenience\n// It's mostly used to transform marker rotation to the rotation we perceive onscreen\n// (Instead of being Y-up oriented)\nAFRAME.registerComponent('marker-tracker', {\n  schema: {\n    marker: {\n      type: 'string',\n      default: \"\"\n    },\n    visibilityOnly: {\n      type: 'boolean',\n      default: false\n    },\n    visibilityTrigger: {\n      type: 'boolean',\n      default: false\n    },\n    isPromiscuous: {\n      type: 'boolean',\n      default: false\n    },\n    lossThreshold: {\n      type: 'number',\n      default: 500\n    }\n  },\n  init: function () {\n    this.el.object3D.isShown = false\n    this.marker = this.data.marker\n\n    this.lossThreshold = this.data.lossThreshold\n    this.lossTime = null\n\n    // These could be settings\n    this.constantZ = -10; // for promiscuous mode\n\n    this.isPromiscuous = this.data.isPromiscuous\n\n    this.trackedMarkers = []\n\n    if (this.isPromiscuous) {\n      let allMarkers = document.querySelectorAll('a-marker');\n      this.trackedMarkers = allMarkers;\n    } else if (this.marker !== \"\") {\n      let markerElement = document.getElementById(this.marker);\n      if (markerElement !== null) {\n        this.trackedMarkers.push(markerElement)\n        this.markerElement = markerElement;\n      }\n    }\n\n    this.positionOffset = this.el.object3D.position.clone()\n  },\n  update: function () {},\n  tick: function () {\n\n    let isVisible = false;\n    let positionToApply = null;\n    let isMainMarker = false;\n\n    let trackedIndex = null;\n    this.trackedMarkers.forEach(function(markerElement, index) {\n      if (markerElement.object3D.visible == true) {\n        isVisible = true;\n        this.lossTime = null;\n\n        // AR.js doesn't properly use its \"size\" property, so we do it here instead:\n        let size = markerElement.getAttribute(\"size\");\n        let scalarAmount = size\n        positionToApply = markerElement.object3D.position.clone().multiplyScalar(size);\n        trackedIndex = index;\n      }\n    });\n\n    if (positionToApply != null) {\n      let origin = this.positionOffset.clone()\n      let updatedPosition = this.el.object3D.position.clone();\n      let positionChange = new THREE.Vector3(0,0,0);\n      let markerPos = positionToApply\n\n      if (!this.data.visibilityOnly) {\n\n        updatedPosition.x = origin.x + markerPos.x\n        updatedPosition.z = origin.z + markerPos.z\n\n        // Kind of a hack, but don't update y position since we printed\n        // the markers at different height on our label\n        if (trackedIndex == 0) {\n          updatedPosition.y = origin.y + markerPos.y\n        }\n\n        let smoothAmount = 0.3\n        let weightedCurrentPos = this.el.object3D.position.clone().multiplyScalar(smoothAmount);\n        let weightedUpdatedPos = updatedPosition.clone().multiplyScalar(1.0 - smoothAmount);\n        let smoothedResult = weightedCurrentPos.add(weightedUpdatedPos);\n\n        // this.el.object3D.position.copy(updatedPosition);\n        this.el.object3D.position.copy(smoothedResult);\n      }\n\n    } else {\n      this.el.object3D.position = this.positionOffset.clone()\n    }\n\n    let exceededMarkerLossThreshold = false;\n    if (!isVisible) {\n      if (this.lossTime == null) {\n        this.lossTime = Date.now();\n      } else {\n\n        let currentTime = Date.now();\n        let delta = Math.abs(currentTime - this.lossTime);\n\n        if (delta > this.lossThreshold) {\n          exceededMarkerLossThreshold = true;\n        }\n      }\n    }\n\n    // If we're using the marker as a visibility trigger, show once we find a marker\n    // Otherwise, don't hide unless we've exceeded our marker loss threshold in seconds\n    if (isVisible){\n      this.lossTime = null;\n      this.el.object3D.visible = true;\n    } else if (!this.data.visibilityTrigger && exceededMarkerLossThreshold) {\n      this.el.object3D.visible = false;\n      this.lossTime = null;\n    }\n  },\n  remove: function () {},\n  pause: function () {},\n  play: function () {}\n});"]}