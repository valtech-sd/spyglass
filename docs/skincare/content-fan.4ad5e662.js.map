{"version":3,"sources":["components/content-fan.js"],"names":["AFRAME","registerComponent","schema","radius","type","default","wiggleEnabled","maxWiggle","init","contentKeyframes","currentContentIndex","angleInterval","startingRotation","animationActive","animationDelta","core","document","createElement","setAttribute","data","el","appendChild","buildWithContentElements","elements","self","numBlades","Math","max","length","PI","forEach","i","currentAngle","dist","planeContainer","x","cos","z","sin","object3D","position","y","rotation","THREE","degToRad","push","reverse","animateContentOffset","offset","wiggleAmount","mapLinear","baseAngle","animateToContent","index","console","log","lastContentIndex","target","targetAngle","curRot","deltaRotation","animation","ANIME","targets","delay","duration","isRawProperty","begin","anim","complete","update","direction","loop","autoplay","easing","play","tick","remove","pause"],"mappings":"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","file":"content-fan.4ad5e662.js","sourceRoot":"../../src/scenario2","sourcesContent":["// This component presents pieces of content as a \"fan\" around a cylinder\n// It can be animated to rotate to each piece of content\nAFRAME.registerComponent('contentfan', {\n  schema: {\n    radius: {\n      type: 'int',\n      default: 1\n    },\n    wiggleEnabled: {\n      type: 'bool',\n      default: true\n    },\n    maxWiggle: {\n      type: 'number',\n      default: 14\n    }\n  },\n  init: function () {\n\n    // The points of rotation for each of our pieces of content\n    this.contentKeyframes = []\n    this.currentContentIndex = -1\n    this.angleInterval = 0\n\n    // Variables required by our animation function\n    // Anime.js must animate a property, or class variable\n    this.startingRotation = 0\n    this.animationActive = false\n    this.animationDelta = 0\n\n    // Add a cylinder geometry\n    // Content blades will be positioned around cylinder\n    // Cylinder parent will be rotated\n    var core = document.createElement('a-cylinder');\n    core.setAttribute(\"wireframe\", false)\n    core.setAttribute(\"opacity\", 0.0)\n    core.setAttribute(\"color\", \"red\")\n    core.setAttribute(\"height\", 14)\n    core.setAttribute(\"radius\", this.data.radius)\n    this.el.appendChild(core);\n\n    this.core = core\n  },\n  // Build the content with an array of data\n  buildWithContentElements: function(elements) {\n\n    let self = this\n\n    // Build some blades on which we'll show some content\n    var numBlades = Math.max(elements.length, 3);\n    // var numBlades = Math.max(elements.length, 3);\n\n    // 2 blades looks dumb\n\n    // How many degrees apart is each blade around the cylinder\n    this.angleInterval = (2 * Math.PI) / numBlades\n\n    elements.forEach(function (el, i) {\n\n      var currentAngle = (i * self.angleInterval)\n      let dist = self.data.radius + 5\n\n      // We create a container so that we can adjust the anchor and pivot point\n      // of the plane...A-Frame has a \"pivot\" component that can do this, but\n      // no way to change the position anchor...this is easier for now.\n      let planeContainer = document.createElement('a-entity');\n      // let planeContainer = document.createElement('a-plane');\n      // planeContainer.setAttribute(\"wireframe\", true)\n      // planeContainer.setAttribute(\"color\", \"blue\")\n      // planeContainer.setAttribute(\"opacity\", 0)\n      // planeContainer.setAttribute(\"height\", 10)\n      // planeContainer.setAttribute(\"width\", 10)\n      // planeContainer.setAttribute(\"material\",\"side: double\")\n\n\n      // Assuming we position around center\n      let x = dist * Math.cos(currentAngle)\n      let z = -dist * Math.sin(currentAngle)\n\n      // Scoot plane over so we're positioning it from the edge\n      // Hardcoded crap\n      el.object3D.position.x = -3.5\n      el.object3D.position.y = 3.5\n\n      // Position plane around cylinder\n      // planeContainer.object3D.position.x = x - 14\n      planeContainer.object3D.position.x = x\n        //- 6\n      planeContainer.object3D.position.z = z\n\n\n      // Rotate so we're mostly facing the camera\n      // TODO: 120 is hardcoded so maybe we'd need to adjust that? Unsure\n      // planeContainer.object3D.rotation.y = (currentAngle + THREE.Math.degToRad(120))\n      planeContainer.object3D.rotation.y = (currentAngle) + THREE.Math.degToRad(0)\n        //+ THREE.Math.degToRad(-360 / numBlades))\n\n      // Save this angle to our \"key frames\" that we can animate to\n      self.contentKeyframes.push(currentAngle)\n\n      // console.log(\"keyframe, \", THREE.Math.radToDeg(currentAngle));\n\n      planeContainer.appendChild(el)\n      self.core.appendChild(planeContainer)\n    });\n\n    // Content should be in REVERSE order of tags\n    // That way, the direction we spin the content matches the direction we detect the markers\n    // TODO: This could be a param\n    this.contentKeyframes.reverse()\n\n    // Set initial rotation\n    if (this.contentKeyframes.length > 0) {\n      this.el.object3D.rotation.y = this.contentKeyframes[0]\n      this.currentContentIndex = 0\n    }\n  },\n\n  // Function is called when the currently-detected marker is \"wiggled\" from side to side\n  // It would probably be best to animate this too, but I got lazy and wanted\n  // to see how it would look just by changing the raw value\n  animateContentOffset: function(offset) {\n    if (this.animationActive || !this.data.wiggleEnabled) {\n      return\n    }\n\n    // If wiggle amount is too large, we may want to animate this as well\n    // flip direction bc\n    let wiggleAmount = THREE.Math.mapLinear(offset, 1.0, 0.0, -this.data.maxWiggle, this.data.maxWiggle)\n\n    let baseAngle = this.contentKeyframes[this.currentContentIndex]\n    this.el.object3D.rotation.y = baseAngle + THREE.Math.degToRad(wiggleAmount)\n  },\n\n  // Called when a new marker is detected\n  // Will rotate cylinder to a different keyframe\n  animateToContent: function(index) {\n\n    console.log(\"animating to content\")\n    if (this.lastContentIndex == this.currentContentIndex) {\n      return\n    }\n\n    // Check if this index is within our content\n    if ((index >= 0) && (index < this.contentKeyframes.length)) {\n\n      let target = this\n\n      var targetAngle = this.contentKeyframes[index]\n      var curRot = this.el.object3D.rotation.y\n\n      var deltaRotation = targetAngle - curRot\n\n      // Find delta in range of -PI to PI\n      // We always want to rotate the minimum amount to get to the marker...(either right or left)\n      // This matches what we'd do in real life\n      if (deltaRotation < -Math.PI) {\n        deltaRotation += 2 * Math.PI\n      } else if (deltaRotation >= Math.PI) {\n        deltaRotation -= 2 * Math.PI\n      }\n\n      this.currentContentIndex = index\n      this.startingRotation = curRot\n\n      // Kind of clunky, but to dynamically make an animation...\n      // We animate a variable within the class...then use that to set the rotation\n      var animation = AFRAME.ANIME({\n        targets: target,\n        animationDelta: [0, deltaRotation],\n        delay: 0,\n        duration: 1500,\n        isRawProperty: true,\n        begin: function(anim) {\n          target.animationActive = true\n        },\n        complete: function(anim) {\n          target.animationActive = false\n        },\n        update: function (animation) {\n          target.el.object3D.rotation.y = target.startingRotation + target.animationDelta\n        },\n        direction: 'normal',\n        loop: false,\n        autoplay: false,\n        easing: 'easeInOutSine'\n      });\n\n      animation.play()\n    }\n  },\n  update: function () {},\n  tick: function () {\n\n  },\n  remove: function () {},\n  pause: function () {},\n  play: function () {}\n});"]}