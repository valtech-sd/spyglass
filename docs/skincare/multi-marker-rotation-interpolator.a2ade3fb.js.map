{"version":3,"sources":["components/multi-marker-rotation-interpolator.js"],"names":["AFRAME","registerComponent","init","tagElements","initialRotation","THREE","Vector3","minTrackDuration","startTrackTime","emittedIndexEvent","trackerLostThreshold","lastTrackedTime","prevTrackedIndex","prevTrackedElement","rotationDelta","minRotation","maxRotation","isTracking","el","querySelectorAll","forEach","tag","setAttribute","onTagIndexTrigger","utils","bind","onTagRotation","addEventListener","e","index","detail","normRot","normalizedRotation","lastTrackedTag","lastTrackedIndex","lastTrackedElement","self","emitTrackingStart","entity","object3D","visible","Date","now","currentTime","deltaTimestamp","Math","abs","emit","console","log","element","update","tick","lastTrackedInfo","lastTag","currentRotation","getAttribute","adjustedRotation","currentPosition","deltaRotationAboutY","y","clampedRotation","clamp","mapLinear","rotation","position","remove","pause","play"],"mappings":"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","file":"multi-marker-rotation-interpolator.a2ade3fb.js","sourceRoot":"../../src","sourcesContent":["// This could be cleaned up more, but we can do that later\n// This class will take a group of indices and emit the index\n// of the current marker that's being detected\n// (or the largest index if multiple markers are detected)\n\n// It will also calculate a wiggle amount if the current marker\n// is rotated slightly about the y-axis\nAFRAME.registerComponent('multi-marker-rotation-interpolator', {\n  init: function () {\n\n    this.tagElements = [];\n    this.initialRotation = new THREE.Vector3(0,0,0)\n\n    this.minTrackDuration = 100 // how long we must track a new marker for before we transition\n    this.startTrackTime = -1 // when we started tracking the current marker\n    this.emittedIndexEvent = false\n\n    this.trackerLostThreshold = 3000\n    this.lastTrackedTime = -1\n\n    this.prevTrackedIndex = -1\n    this.prevTrackedElement = null\n    this.rotationDelta = 0\n    this.minRotation = -50\n    this.maxRotation = 50\n\n    this.isTracking = false;\n\n    // Find all of the tags in this group\n    this.tagElements = this.el.querySelectorAll('a-marker');\n\n    // Add adjusted rotation component to tag elements, if it doesn't already exist\n    // This transforms the tag's coordinate frame to match what we see on camera\n    this.tagElements.forEach( function(tag) {\n      tag.setAttribute(\"adjusted-rotation\", \"\")\n    })\n\n    // Set up event handlers\n    this.onTagIndexTrigger = AFRAME.utils.bind(this.onTagIndexTrigger, this);\n    this.onTagRotation = AFRAME.utils.bind(this.onTagRotation, this);\n\n    this.el.addEventListener('tag-index-trigger', this.onTagIndexTrigger);\n    this.el.addEventListener('tag-rotation', this.onTagRotation);\n  },\n  onTagIndexTrigger: function(e) {\n    // Emit the index of the tag that was detected\n    let index = e.detail.index\n  },\n  onTagRotation: function(e) {\n\n    // Emit a normalized rotation amount if the current\n    // tag is rotated about the y-index\n    let index = e.detail.index\n    let normRot = e.detail.normalizedRotation\n  },\n  lastTrackedTag: function () {\n\n    // Figures out which tag in the group is being tracked\n    // Or...if multiple tags are tracked, the largest index\n    var lastTrackedIndex = -1; // None tracked\n    var lastTrackedElement = null;\n\n    let self = this\n    var emitTrackingStart = false;\n\n    this.tagElements.forEach(function (tag, index) {\n      let entity = tag.object3D\n\n      if (entity.visible) {\n        self.lastTrackedTime = Date.now()\n        lastTrackedIndex = index\n        lastTrackedElement = tag\n\n        // This is our first tracked tag\n        if (!self.isTracking) {\n          emitTrackingStart = true;\n        }\n\n        // console.log(\"e visible\")\n        // console.log('prev track ', lastTrackedIndex)\n        if (this.prevTrackedIndex != lastTrackedIndex) {\n\n          // start our time\n          self.emittedIndexEvent = false;\n          self.startTrackTime = Date.now()\n\n        } else {\n\n          if (!self.emittedIndexEvent) {\n            let currentTime = Date.now()\n            let deltaTimestamp = (self.startTrackTime == -1) ? 0 : Math.abs(currentTime - self.startTrackTime)\n\n            if (deltaTimestamp > self.minTrackDuration){\n              self.el.emit(\"tag-index-trigger\", { index: lastTrackedIndex });\n              self.emittedIndexEvent = true\n\n              console.log(\"emitting trigger\")\n            }\n          }\n        }\n\n        if (emitTrackingStart) {\n          self.isTracking = true;\n          self.el.emit(\"tracking-started\", { index: lastTrackedIndex });\n        }\n\n        this.prevTrackedIndex = lastTrackedIndex\n        this.prevTrackedElement = lastTrackedElement\n      }\n    })\n\n    if (lastTrackedElement == null && this.lastTrackedTime != null) {\n\n      let currentTime = Date.now()\n      let deltaTimestamp = Math.abs(currentTime - this.lastTrackedTime)\n\n      if ((deltaTimestamp > this.trackerLostThreshold) && this.isTracking) {\n        self.lastTrackedIndex = -1;\n        this.isTracking = false;\n        self.el.emit(\"tracking-ended\", { index: lastTrackedIndex });\n      }\n    }\n    return { index: lastTrackedIndex, element: lastTrackedElement }\n  }\n  ,\n  update: function () {},\n  tick: function () {\n\n    let entity = this.el.object3D\n\n    if (entity.visible) {\n\n      let lastTrackedInfo = this.lastTrackedTag()\n\n      // Figure out last tag visible\n      let lastTag = this.lastTrackedTag().element\n\n      if (lastTag && this.emittedIndexEvent) {\n        // Get adjusted rotation\n        let currentRotation = lastTag.getAttribute('adjusted-rotation').adjustedRotation\n        let currentPosition = lastTag.getAttribute(\"position\")\n\n        // Compute delta from starting rotation\n        // Focus on \"flip\" rotation about y-axis\n        let deltaRotationAboutY = this.initialRotation.y - currentRotation.y\n\n        // Compute normalized value of rotation, clamping to min/max rotation\n        let clampedRotation = THREE.Math.clamp(deltaRotationAboutY, this.minRotation, this.maxRotation)\n        let normalizedRotation = THREE.Math.mapLinear(clampedRotation, this.minRotation, this.maxRotation, 0, 1)\n\n        // this.el.emit(\"tag-rotation\", { index: lastTrackedInfo.index, normalizedRotation: normalizedRotation });\n        this.el.emit(\"tag-rotation\", { index: lastTrackedInfo.index, rotation: currentRotation });\n        this.el.emit(\"tag-position\", { index: lastTrackedInfo.index, position: currentPosition });\n\n      }\n    }\n\n  },\n  remove: function () {},\n  pause: function () {},\n  play: function () {}\n})"]}